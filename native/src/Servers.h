#ifndef SERVERS
#define SERVERS

#include "../include/public_header.h"
#include "process_noise.h"
#include "Server.h"

class Servers
{
public:
    gamal_key_t coll_key; //collective key pair
    vector<Server> server_vect; // servers
    int server_size; // number of servers
    int data_size; //participant's dataset size
    int scale_up_factor; //scaled-up factor of histogram size
    int domain_size; // total number of possible records

    gamal_ciphertext_t *s_myPIR_enc; // encrypted sampling vector of length N+1 generated by 1 of the servers
    int *s_plain_track_list; //clear sampling vector

    double maxNoise; //maximum noise can be added to participant's answer for DP guarantee
    double minNoise; //minimum noise can be added to participant's answer
    double pv_ratio; //partial view size to dataset size ratio

    id_domain_set known_rows_after_phase2, verified_set, opened_rows_set, known_record_set, rows_set_in_opened_PV;

    // Servers();
    // Servers(int server_size, int data_size, string known_domain_dir);

/**
 * This function initiate a vector of server
 * @para: server_size: number of servers
 * @para: data_size: participant's dataset size
 * @para: known_domain_dir: directory to the background knowledge subset
 * @para: scale_up_factor: "a" used by participant to make a histogram of size aN
*/
    Servers(int server_size, int data_size, string known_domain_dir, int scale_up_factor);

    

/**
 * This function for all servers to generate collective key pair
 * collective public key is known to all servers
 * collective secret key is never reconstructed unless all servers collude
*/
    void generateCollKey();


/**
 * This function for all servers to jointly decrypt a ciphertext get the final plaintext
 * @para: ciphertext to be decrypted
 * @para: table: lookup table for mapping a EC point to original integer
 * @para: serverID: the server initiates the threshold decryption
 * @return: the plaintext
*/
    dig_t _fusionDecrypt(gamal_ciphertext_t ciphertext, bsgs_table_t table, int serverId);


/**
 * This function for a server to generate a encrypted binary vector of length N+1 for sampling vector
 * @para: pre_enc_stack: pre computed enc(0) and enc(1) stack
 * @return: a sampling vector of size N+1 with V enc(1) and N-V enc(0) and last one is enc(0)
*/

    void createPVsamplingVector_size_N_plus_1(ENC_Stack &pre_enc_stack);

/**
 * This function is for all servers to verify the submitted partial view
 * Condition for passing the verification is generated inside the function
 * @para: enc_domain_map: encrypted partial view sent be a participant
 * @para: table: a lookup table for decryption
 * @para: serverID: the server to initiate the threshold decryption
 * @para: &pre_enc_stack: stack of precomputed encryption of servers
 * to get an enc(0) for the special case where there is no known record found in the PV,
 * we need to decrypt the encrypted total number of known records found in PV
 * the encrypted total number of known records is initiated with enc(0)
 * @para: eta: the tolerated false positve rate that the verification can have
 * @return: a true/fale boolean: 1=pass; 0=fail
*/
    bool verifyingPV(ENC_DOMAIN_MAP enc_domain_map, bsgs_table_t table, int serverId, ENC_Stack &pre_enc_stack, double eta);
    

/**
 * This function is for servers to jointly decrypt the test answer from the participant
 * and check if the decrypted answer satisfies the condition of the test
 * @para: testName: specify the test to the server
 * @para: sum_cipher: the encrypted noisy answer from participant
 * @para: table: lookup table for decryption
 * @para: serverID: the server which initiate (lead) the decryption
 * @para: threshold: expected answer
 * @return: a status that pass/fail the test
*/
    bool verifyingTestResult(string testName, gamal_ciphertext_t sum_cipher, bsgs_table_t table, int serverId, int threshold);

/** 
 * This function is to verify if the test answer from the participant is within the
 * confidence interval +/- noise
 * the servers decrypt answer from participant
 * then find conf_interval +- maxnoise
 * the answer from participant must be in [min_interval - maxnoise; max_interval + maxnoise]
 * @para: testName: specify the test to the server
 * @para: sum_cipher: encrypted answer from participant 
 * @para: table: lookup table for decryption
 * @para: enc_PV_answer: encrypted answer from the function getTestResult_fromPV()
 * @para: alpha = 0.05 // 95% confidence level
 * @return: a status that pass/fail the test
 */
    bool verifyingTestResult_Estimate(string testName, gamal_ciphertext_t sum_cipher, bsgs_table_t table, int serverId, gamal_ciphertext_t enc_PV_answer, double alpha);

/**
 * this function is to estimate the test results computed over the dataset based on
 * the result the servers achieved from the encrypted PV
 */
    vector<double> estimate_conf_interval(double alpha, int PV_answer, int dataset_size, int PV_size);




//===================== Supportive functions or unused functions ====================================================//

/**
 * This function is for a server to create a sampling vector of size N
 * @para: ciphertext to be decrypted
 * @return: an encrypted sample vector of length N
*/    
    
    void createPVsamplingVector(ENC_Stack &pre_enc_stack);



/**
 * This function saves known records in background knowledge found in the partial view
 * @para: known records found in the PV
 * @return: a subset of known records found in the PV
 */    
    void save_knownRow_found_in_PV(id_domain_pair verified_domain_pair);

/**
 * This function saves rows were opened by the server during the partial view verification
 */
    void save_opened_rows(id_domain_pair opened_rows);

/**
 * This fuction saves all rows that serves know about the dataset after PV phase
 */    
    void save_knownRow_after_phase2(id_domain_pair domain_pair);    


    void open_true_PV(ENC_DOMAIN_MAP enc_domain_map, bsgs_table_t table, int serverId, ENC_Stack &pre_enc_stack);

    void fusionDecrypt(ENC_DOMAIN_MAP enc_domain_map, bsgs_table_t table);

};

#endif